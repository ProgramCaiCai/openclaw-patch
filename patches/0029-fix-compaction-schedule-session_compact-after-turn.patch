From 093e137ee866e9439a5140a9ba721fc296f34283 Mon Sep 17 00:00:00 2001
From: programcaicai <programcaicai@programcaicaideMac-mini.local>
Date: Wed, 4 Feb 2026 16:34:10 +0800
Subject: [PATCH 29/44] fix(compaction): schedule session_compact after turn

---
 src/agents/tools/session-compact-tool.ts | 134 ++++++++++++++---------
 1 file changed, 83 insertions(+), 51 deletions(-)

diff --git a/src/agents/tools/session-compact-tool.ts b/src/agents/tools/session-compact-tool.ts
index d46e940c4..973812b8b 100644
--- a/src/agents/tools/session-compact-tool.ts
+++ b/src/agents/tools/session-compact-tool.ts
@@ -8,15 +8,19 @@ import {
   updateSessionStore,
   type SessionEntry,
 } from "../../config/sessions.js";
+import { resolveSessionFilePath } from "../../config/sessions.js";
 import { enqueueSystemEvent } from "../../infra/system-events.js";
-import { resolveSessionAgentId } from "../agent-scope.js";
-import { compactEmbeddedPiRun } from "../pi-embedded-runner/runs.js";
+import { resolveAgentWorkspaceDir, resolveSessionAgentId } from "../agent-scope.js";
+import { compactEmbeddedPiSession } from "../pi-embedded.js";
 import { readStringParam } from "./common.js";
 
 const SessionCompactToolSchema = Type.Object({
   instructions: Type.Optional(Type.String({ minLength: 1 })),
 });
 
+// Prevent duplicate compaction scheduling for the same session.
+const SCHEDULED_COMPACTIONS = new Set<string>();
+
 export function createSessionCompactTool(opts?: {
   agentSessionKey?: string;
   agentSessionId?: string;
@@ -50,68 +54,96 @@ export function createSessionCompactTool(opts?: {
       }
 
       const cfg = opts?.config ?? loadConfig();
-      const result = await compactEmbeddedPiRun(sessionId, instructions);
 
-      if (result.ok && result.compacted && result.result?.summary) {
-        // Best-effort: bump compactionCount for UI/status; ignore failures.
-        try {
-          const agentId = resolveSessionAgentId({ sessionKey, config: cfg });
-          const storePath = resolveStorePath(cfg.session?.store, { agentId });
-          const store = loadSessionStore(storePath);
-          const entry = store[sessionKey];
-          const nextCount = (entry?.compactionCount ?? 0) + 1;
-          const updates: Partial<SessionEntry> = {
-            compactionCount: nextCount,
-            updatedAt: Date.now(),
-          };
-          if (result.result.tokensAfter && result.result.tokensAfter > 0) {
-            updates.totalTokens = result.result.tokensAfter;
-            updates.inputTokens = undefined;
-            updates.outputTokens = undefined;
-          }
-          await updateSessionStore(storePath, (next) => {
-            next[sessionKey] = { ...(next[sessionKey] ?? {}), ...updates };
-          });
-        } catch {
-          // Ignore store update failures.
-        }
+      const agentId = resolveSessionAgentId({ sessionKey, config: cfg });
+      const storePath = resolveStorePath(cfg.session?.store, { agentId });
+      const store = loadSessionStore(storePath);
+      const entry = store[sessionKey];
+      if (!entry?.sessionId) {
+        return {
+          content: [
+            {
+              type: "text",
+              text: "session_compact is unavailable (missing session entry). Use /compact instead.",
+            },
+          ],
+          details: { ok: false, compacted: false, reason: "missing session entry" },
+        };
+      }
 
-        enqueueSystemEvent("Session compacted.", { sessionKey });
+      if (!SCHEDULED_COMPACTIONS.has(sessionId)) {
+        SCHEDULED_COMPACTIONS.add(sessionId);
+        void (async () => {
+          try {
+            // Queue compaction behind the current session lane; do not run inside the active attempt.
+            const sessionFile = resolveSessionFilePath(sessionId, entry, { agentId });
+            const workspaceDir = resolveAgentWorkspaceDir(cfg, agentId);
 
-        const tokensLine =
-          typeof result.result.tokensBefore === "number"
-            ? `Tokens before: ${result.result.tokensBefore}${
-                typeof result.result.tokensAfter === "number"
-                  ? `; after: ${result.result.tokensAfter}`
-                  : ""
-              }`
-            : undefined;
+            const result = await compactEmbeddedPiSession({
+              sessionId,
+              sessionKey,
+              messageChannel: entry.lastChannel ?? entry.channel,
+              groupId: entry.groupId,
+              groupChannel: entry.groupChannel,
+              groupSpace: entry.space,
+              spawnedBy: entry.spawnedBy,
+              sessionFile,
+              workspaceDir,
+              config: cfg,
+              skillsSnapshot: entry.skillsSnapshot,
+              provider: entry.providerOverride ?? entry.modelProvider,
+              model: entry.modelOverride ?? entry.model,
+              bashElevated: {
+                enabled: false,
+                allowed: false,
+                defaultLevel: "off",
+              },
+              customInstructions: instructions,
+            });
 
-        const text = [
-          "Session compaction complete.",
-          tokensLine,
-          "",
-          "Summary:",
-          result.result.summary,
-        ]
-          .filter(Boolean)
-          .join("\n");
+            if (result.ok && result.compacted) {
+              // Best-effort: bump compactionCount for UI/status; ignore failures.
+              try {
+                await updateSessionStore(storePath, (next) => {
+                  const currentEntry = next[sessionKey];
+                  const nextCount = (currentEntry?.compactionCount ?? 0) + 1;
+                  const updates: Partial<SessionEntry> = {
+                    compactionCount: nextCount,
+                    updatedAt: Date.now(),
+                  };
+                  if (result.result?.tokensAfter && result.result.tokensAfter > 0) {
+                    updates.totalTokens = result.result.tokensAfter;
+                    updates.inputTokens = undefined;
+                    updates.outputTokens = undefined;
+                  }
+                  next[sessionKey] = { ...currentEntry, ...updates };
+                });
+              } catch {
+                // Ignore store update failures.
+              }
 
-        return {
-          content: [{ type: "text", text }],
-          details: result,
-        };
+              enqueueSystemEvent("Session compacted.", { sessionKey });
+            } else {
+              const reason = result.reason?.trim() || (result.ok ? "not compacted" : "error");
+              enqueueSystemEvent(`Session compaction did not run: ${reason}.`, { sessionKey });
+            }
+          } catch (err) {
+            const reason = err instanceof Error ? err.message : String(err);
+            enqueueSystemEvent(`Session compaction failed: ${reason}`, { sessionKey });
+          } finally {
+            SCHEDULED_COMPACTIONS.delete(sessionId);
+          }
+        })();
       }
 
-      const reason = result.reason?.trim() || (result.ok ? "not compacted" : "error");
       return {
         content: [
           {
             type: "text",
-            text: `Session compaction did not run: ${reason}. You can try /compact.`,
+            text: "Session compaction scheduled. It will run after the current turn finishes (equivalent to /compact).",
           },
         ],
-        details: result,
+        details: { ok: true, compacted: false, reason: "scheduled" },
       };
     },
   };
-- 
2.50.1 (Apple Git-155)

