From b19b39d009b5492726012ee98880b7bd23f1c1df Mon Sep 17 00:00:00 2001
From: programcaicai <programcaicai@programcaicaideMac-mini.local>
Date: Wed, 4 Feb 2026 16:55:20 +0800
Subject: [PATCH 30/44] fix(compaction): retry session_compact on transient 503

---
 src/agents/tools/session-compact-tool.ts | 130 +++++++++++++++--------
 1 file changed, 83 insertions(+), 47 deletions(-)

diff --git a/src/agents/tools/session-compact-tool.ts b/src/agents/tools/session-compact-tool.ts
index 973812b8b..0c76656f5 100644
--- a/src/agents/tools/session-compact-tool.ts
+++ b/src/agents/tools/session-compact-tool.ts
@@ -74,58 +74,94 @@ export function createSessionCompactTool(opts?: {
       if (!SCHEDULED_COMPACTIONS.has(sessionId)) {
         SCHEDULED_COMPACTIONS.add(sessionId);
         void (async () => {
+          const sleep = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));
+          const isTransient = (reason: string) => {
+            const r = reason.toLowerCase();
+            return (
+              // Common transient transport/provider failures.
+              r.includes("503") ||
+              r.includes("temporarily unavailable") ||
+              r.includes("fetch failed") ||
+              r.includes("econnreset") ||
+              r.includes("etimedout") ||
+              // CN provider/router message seen in the wild.
+              reason.includes("所有供应商暂时不可用")
+            );
+          };
+
+          // Queue compaction behind the current session lane; do not run inside the active attempt.
+          const sessionFile = resolveSessionFilePath(sessionId, entry, { agentId });
+          const workspaceDir = resolveAgentWorkspaceDir(cfg, agentId);
+
+          // Retry a few times on transient 503/network failures.
+          const retryDelaysMs = [0, 60_000, 180_000];
+
           try {
-            // Queue compaction behind the current session lane; do not run inside the active attempt.
-            const sessionFile = resolveSessionFilePath(sessionId, entry, { agentId });
-            const workspaceDir = resolveAgentWorkspaceDir(cfg, agentId);
-
-            const result = await compactEmbeddedPiSession({
-              sessionId,
-              sessionKey,
-              messageChannel: entry.lastChannel ?? entry.channel,
-              groupId: entry.groupId,
-              groupChannel: entry.groupChannel,
-              groupSpace: entry.space,
-              spawnedBy: entry.spawnedBy,
-              sessionFile,
-              workspaceDir,
-              config: cfg,
-              skillsSnapshot: entry.skillsSnapshot,
-              provider: entry.providerOverride ?? entry.modelProvider,
-              model: entry.modelOverride ?? entry.model,
-              bashElevated: {
-                enabled: false,
-                allowed: false,
-                defaultLevel: "off",
-              },
-              customInstructions: instructions,
-            });
-
-            if (result.ok && result.compacted) {
-              // Best-effort: bump compactionCount for UI/status; ignore failures.
-              try {
-                await updateSessionStore(storePath, (next) => {
-                  const currentEntry = next[sessionKey];
-                  const nextCount = (currentEntry?.compactionCount ?? 0) + 1;
-                  const updates: Partial<SessionEntry> = {
-                    compactionCount: nextCount,
-                    updatedAt: Date.now(),
-                  };
-                  if (result.result?.tokensAfter && result.result.tokensAfter > 0) {
-                    updates.totalTokens = result.result.tokensAfter;
-                    updates.inputTokens = undefined;
-                    updates.outputTokens = undefined;
-                  }
-                  next[sessionKey] = { ...currentEntry, ...updates };
-                });
-              } catch {
-                // Ignore store update failures.
+            for (let attempt = 0; attempt < retryDelaysMs.length; attempt++) {
+              const delayMs = retryDelaysMs[attempt];
+              if (delayMs > 0) {
+                enqueueSystemEvent(
+                  `Session compaction retry scheduled in ${Math.round(delayMs / 1000)}s.`,
+                  { sessionKey },
+                );
+                await sleep(delayMs);
+              }
+
+              const result = await compactEmbeddedPiSession({
+                sessionId,
+                sessionKey,
+                messageChannel: entry.lastChannel ?? entry.channel,
+                groupId: entry.groupId,
+                groupChannel: entry.groupChannel,
+                groupSpace: entry.space,
+                spawnedBy: entry.spawnedBy,
+                sessionFile,
+                workspaceDir,
+                config: cfg,
+                skillsSnapshot: entry.skillsSnapshot,
+                provider: entry.providerOverride ?? entry.modelProvider,
+                model: entry.modelOverride ?? entry.model,
+                bashElevated: {
+                  enabled: false,
+                  allowed: false,
+                  defaultLevel: "off",
+                },
+                customInstructions: instructions,
+              });
+
+              if (result.ok && result.compacted) {
+                // Best-effort: bump compactionCount for UI/status; ignore failures.
+                try {
+                  await updateSessionStore(storePath, (next) => {
+                    const currentEntry = next[sessionKey];
+                    const nextCount = (currentEntry?.compactionCount ?? 0) + 1;
+                    const updates: Partial<SessionEntry> = {
+                      compactionCount: nextCount,
+                      updatedAt: Date.now(),
+                    };
+                    if (result.result?.tokensAfter && result.result.tokensAfter > 0) {
+                      updates.totalTokens = result.result.tokensAfter;
+                      updates.inputTokens = undefined;
+                      updates.outputTokens = undefined;
+                    }
+                    next[sessionKey] = { ...currentEntry, ...updates };
+                  });
+                } catch {
+                  // Ignore store update failures.
+                }
+
+                enqueueSystemEvent("Session compacted.", { sessionKey });
+                return;
               }
 
-              enqueueSystemEvent("Session compacted.", { sessionKey });
-            } else {
               const reason = result.reason?.trim() || (result.ok ? "not compacted" : "error");
+              if (!result.ok && isTransient(reason) && attempt < retryDelaysMs.length - 1) {
+                // Try again after backoff.
+                continue;
+              }
+
               enqueueSystemEvent(`Session compaction did not run: ${reason}.`, { sessionKey });
+              return;
             }
           } catch (err) {
             const reason = err instanceof Error ? err.message : String(err);
-- 
2.50.1 (Apple Git-155)

